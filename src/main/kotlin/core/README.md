
## LinkedList vs ArrayList

ArrayList следует использовать, когда в приоритете доступ по индексу, 
так как эти операции выполняются за константное время. 
Добавление в конец списка в среднем тоже выполняется за константное время. 
Кроме того в ArrayList нет дополнительных расходов на хранение связки между элементами. 
Минусы в скорости вставки/удаления элементов находящихся не в конце списка, 
так как при этой операции все элементы правее добавляемого/удаляемого сдвигаются.

LinkedList удобен когда важнее быстродействие операций вставки/удаления, 
которые в LinkedList выполняются за константное время. 
Операции доступа по индексу производятся перебором 
с начала или конца (смотря что ближе) до нужного элемента. 
Дополнительные затраты на хранение связки между элементами.

НО!!!!!!  
при использовании итератора для linked list уходит чатсь проблем  

LinkedList используется если необходимо производить много операций 
вставки/удаления элементов в середине списка и мало операций 
доступа к элементу по индексу.

Добавим 20_000_000 миллион строк.

В итоге получаем примерно так

| Operation                  | ArrayList | LinkedList |
|----------------------------|-----------|------------|
| add (в начало)             | O(n)      | O(1)       |
| add (в середину)           | O(n)      | O(n)       |
| add (в конец списка)       | O(n)      | O(1)       |

| Operation                  | ArrayList | LinkedList |
|----------------------------|-----------|------------|
| get (первый элемент)       | O(1)      | O(1)       |
| get (из середины)          | O(1)      | O(n)       |
| get (последний элемент)    | O(1)      | O(1)       |

| Operation                  | ArrayList | LinkedList |
|----------------------------|-----------|------------|
| delete (первый элемент)    | O(n)      | O(1)       |
| delete (из середины)       | O(n)      | O(n) - худ |
| delete (последний элемент) | O(1)      | O(1)       |

## HashSet

Sets do not have keys, you need yo traverse them to get the objects.

## Delegate properties
Делегированные свойства позволяют делегировать получение или присвоение их значения во вне - другому классу. 
Это позволяет нам добавить некоторую дополнительную логику при операции со свойствами, например, 
логгирование, какую-то предобработку и т.д.

После типа данных свойства идет ключевое слово by, после которого указывается выражение. 
Выражение представляет класс, который условно называется делегатом. Делегаты свойств могут 
не применять никаких интерфейсов, однако они должны предоставлять функции getValue() и setValue(). 
А выполнение методов доступа get() и set(), которые есть у свойства, делегируется функциям 
getValue() и setValue() класса делегата.

В рабочем проекте как-то понадобилось назначать рандомные свойства (определенный диапазон) 
параметрам в классах. Условием было еще то, что свойство могло принимать разные типы. 
Можно конечно было решить через геттер, но я выбрал делегаты.

Итак, вот мой базовый класс Rand со свойством только для чтения

```kotlin
class Rand<V>(private vararg val list: V) {
    operator fun <T> getValue(thisRef: T, property: KProperty<*>): V {
        return list[Random.nextInt(0,list.size)]
    }
}
```
Теперь накидаем тестовый класс для проверки работы
```kotlin
class TestUser {
    val age by Rand(16,23,45,true)
    val name by Rand("Sara", "Demi", "Julia")
}
```
В итоге свойству _age_ или _name_ можно присвоить свойство любого типа. Выглядит лаконично.  

#### Полезные ссылки

- [Ссылка](https://kotlinlang.org/docs/delegated-properties.html) на официальную документацию
- Добротная [документация](https://metanit.com/kotlin/tutorial/5.6.php) на сайте metanit