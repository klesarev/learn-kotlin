## Оглавление
- Компиляция Kotlin
- Тип Unit
- Object Declarations
- Companion object
- Typealias
- Inline functions и Reified
- Тип Nothing и Any
- Типы данных (примитивы) и autoboxing
- Sequences
- Функции высшего порядка, лямбды и анонимные функции
- Интерфейсы
- Extension функции
- Отличие _const_ от _val_
- Дженерики. Отличие от дженериков в Java
- Зачем нужны корутины? Почему бы не наплодить обычных тредов?


### Что за тип такой — Unit? Зачем нужен?  
Unit — эквивалент типа void в Java. Другими словами, он нужен для того, чтобы показать, что функция ничего
не возвращает. Unit наследуется от типа Any, а при работе с Java-кодом автоматически транслируется в void.

### Как компилируются object declarations и companion objects?
Ключевое слово object позволяет одновременно объявить класс и создать его экземпляр (или другими словами, объект). 
При этом использовать его можно по-разному:
- объявление объекта;
- реализация объекта-компаньона;
- запись объекта-выражения (также известен как анонимный объект и object expressions).

Object компилируется в статический класс со статическим полем, 
имя которого INSTANCE. с компаньонами тоже самое, но если имя не указано, 
оно будет Companion

### Какая польза от typealias? Во что он компилируется?   
Польза в более лаконичном названии уже существующих классов и переменных. Компилируется в public final class

### Что такое reified и для чего он нужен?  
**Reified** - это ключевое слово, которое может быть использовано только в inline-функциях.
Его цель - получение доступа к информации о типе класса.
Параметры, отмеченные этим ключевым словом, ещё называют овеществляемыми.
Ключевое __reified__ слово указывается перед типом, информацию о котором мы хотим получить внутри функции.
Также **reified** может быть использован в другом сценарии: для возврата из функции разных типов данных.

В качестве примера можно привести пример метода RestAssured, который при get запросе возвращает 
список элементов.
```kotlin
inline fun <reified T> getDataList(url: String): List<T> {
    return RestAssured.given()
        .`when`()
        .get(url)
        .then()
        .extract().body.jsonPath()
        .getList(path, T::class.java)
}
```
Теперь надо создать для теста data класс (с дефолтными ) и получить результат.
```kotlin
data class ListElement(
    val name: String = "",
    val age: Int = 0,
    val id: Int = 0,
)

val result = getDataList<ListElement>()
```
Почему reified возможно использовать только с встроенными функциями? Когда мы вызываем 
inline-функцию, у которой параметр отмечен ключевым словом reified, 
компилятор определяет тип этого параметра и генерирует байт-код, 
который ссылается на конкретный класс. А так как в байт-коде указан конкретный класс, 
а не типовой параметр, типовой аргумент не стирается во время выполнения. 
Этот байт-код в последующем будет вставляться в точки вызова inline-функции.

### Зачем нужен тип Nothing, какие выражения имеют такой тип? Какие ограничения накладываются на Nothing?
Nothing — класс, который является наследником любого класса в Kotlin. Nothing нельзя 
создать — у него приватный конструктор.

Ниже пример из официальной документации.
```kotlin
fun fail(message: String): Nothing {
    throw IllegalArgumentException(message)
}
```
При вызове такой функции компилятор будет в курсе, что исполнения кода далее не последует
```kotlin
val s = person.name ?: fail("Name required")
println(s) // переменная 's' инициализирована к этому моменту
```
Вообще, если из метода нужно вернуть чуть более, 
чем просто null? Например, узнать тип ошибки, вот тут Nothing однозначно пригодится.

### Когда компилятор использует примитивные типы? В каких случаях происходит автобоксинг?
В Kotlin нет примитивных типов - все ссылочные (String, Int, Float и.т.д).
Когда код kotlin компилируется в код jvm, всякий раз, когда это возможно, "примитивный объект" 
преобразуется в примитивный java. В некоторых случаях это невозможно сделать. 
Такими случаями являются, например, коллекция "примитивов". 
Например, List<Int>не может содержать примитив, в результате чего autoboxing таки будет срабатывать, 
как это было бы для любого кода с обобщениями в Java.

### Какие объекты выделяются при вызове forEach, map, reduce, fold и т. п. на Iterable? на Sequence?
Text here...

### Зачем вообще нужны Sequences?
text here...

### Что такое функциональный тип, какие у него ограничения?
text here...

### Как работают SAM-conversions?
### Что такое функции высшего порядка (higher-order functions), лямбда-выражения (lambda-expressions), анонимные функции (anonymous functions), указатели на методы (method references, bound callable references)?
### Какой толк от inline-функций, как компилируется сама функция и места её использования?
### Как работают crossinline и noinline?
### Можно ли в лямбде изменить значение переменной, захваченной из внешней области видимости? Как это работает в inline-функциях? noinline-функциях? во многопоточном окружении?
### Что использовать вместо try-with-resources?
### Как компилируются default-методы в интерфейсах?
### Как компилируются extension-функции и как использовать их из Java?
### Можно ли сделать extension к интерфейсу? Тайпалиасу? Функциональному типу?
### Может ли функция быть одновременно member и extension? Как её использовать?
### Почему присваивания — не выражения (assignments are not expressions)?
### Что такое exhaustive when, на каких типах он возможен?
### Чем дженерики в Kotlin отличаются от джавовых?
### Что такое declaration-site variance? Где помогает, где затрудняет разработку, как выглядит из Java?
### Как устроен reified, почему работает только в inline-функциях?
### Как с помощью reified получить не сырой тип (класс), а параметризованный тип (parameterized type) со всеми его аргументами (actual type arguments)?

